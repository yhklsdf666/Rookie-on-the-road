![](https://i.imgur.com/OKektIj.png)

![](https://i.imgur.com/1TLEb4M.jpg)

```java
package 设计模式;

import IO流.FileUtilClose;

import java.io.*;
import java.lang.reflect.Constructor;
import java.util.concurrent.CountDownLatch;

public class Singleton {
    public static void main(String[] args) throws Exception {

        Singleton2 s1 = Singleton2.getInstance();
        Singleton2 s2 = Singleton2.getInstance();

        System.out.println(s1 == s2);

        /*通过反射的方式直接调用私有构造器*/
        Class<Singleton2> clazz = (Class<Singleton2>) Class.forName("设计模式.Singleton2");
        Constructor<Singleton2> c = clazz.getDeclaredConstructor(null);
        //跳过安全检查
        c.setAccessible(true);
        Singleton2 s3 = c.newInstance();
        Singleton2 s4 = c.newInstance();
        System.out.println(s3 == s4);

        /*通过反序列化的方式构造多个对象*/
        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("D:\\英语\\test"));
        ObjectInputStream ois = new ObjectInputStream(new FileInputStream("D:\\英语\\test"));
        oos.writeObject(s1);
        Singleton2 s5 = (Singleton2) ois.readObject();
        FileUtilClose.close(ois, oos);
        System.out.println(s1 == s5);

        /*测试多线程模式下五种创建单例模式的效率*/
        long startTime = System.currentTimeMillis();

        int threadNum = 10;
        final CountDownLatch count = new CountDownLatch(threadNum);

        for (int i = 0; i < threadNum; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int j = 0; j < 100000; j++) {
                        Object o = Singleton2.getInstance();
//                        Object o = Singleton5.INSTANCE;
                    }
                    //内部类引用外部的局部变量，因为生命周期不一致所以要声明成final不变的常量
                    count.countDown();
                }
            }).start();
        }

        //main线程阻塞，实际for(;;)循环检测直到计数器变为0才继续向下执行
        count.await();
        
//        暂停正运行线程
//        _.join();
//        暂停该静态方法所在线程
//        Thread.yield();
        
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime);
    }
}

//饿汉式
class Singleton1 {
    //类初始化时，立即加载这个对象（没有延时加载优势），天然的是线程安全的。
    private static Singleton1 instance = new Singleton1();

    private Singleton1() {
    }

    //方法没有同步，调用效率高。
    public static Singleton1 getInstance() {
        return instance;
    }
}

//懒汉式
class Singleton2 implements Serializable {

    private static Singleton2 instance = null;

    private Singleton2() {
//        防止反射漏洞
//        if (instance != null) {
//            throw new RuntimeException();
//        }
    }

    //懒加载，资源利用率高，但是因为方法需要同步，所以并发效率低。
    public static synchronized Singleton2 getInstance() {
        if (instance == null) {
            instance = new Singleton2();
        }
        return instance;
    }

//    防止反序列化漏洞,反序列化时会自动调用该方法
//    private Object readResolve() {
//        return instance;
//    }
}

//由于编译器优化和Jvm底层内部模型原因偶尔会出问题，不建议使用
class Singleton3 {
    //声明一个私有的静态变量
     private static Singleton3 instance = null;

    //构造器私有化，避免外部直接创建对象
     private Singleton3() {
    }

    public static Singleton3 getInstance() {
         //双重检测
        if (null == instance) {             //提高效率
            synchronized (Singleton.class) {
                if (null == instance) {     //安全
                    instance = new Singleton3();
                }
            }
        }
        return instance;
    }
}



//静态内部类实现，并发高效，延时加载
class Singleton4 {
    //初始化类时不会加载该静态内部类，调用方法时才会加载
    private static class Singletonholder {
        private static final Singleton4 instance = new Singleton4();
    }

    private Singleton4() {
    }

    public static Singleton4 getInstance() {
        return Singletonholder.instance;
    }
}

//枚举式实现单例模式，本身就是单例模式，由Jvm从根本上提供保障，避免通过反射和反序列化的漏洞，缺点是无延迟加载
enum Singleton5 {

    //这个枚举元素本身就是单例对象
    INSTANCE;

    //添加自己需要的操作
    public void singletonOperation() {

    }
}
```

![](https://i.imgur.com/TwKNLb8.jpg)

