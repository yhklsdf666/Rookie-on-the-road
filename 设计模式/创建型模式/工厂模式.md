### 工厂模式

#### 作用

- 实现了创建者和调用者的分离

#### ![](https://i.imgur.com/RjanRqW.jpg)

#### 详细分类

##### 示例代码

```java
public interface Car {
    void run();
}
```

```java
public class Audi implements Car {
    @Override
    public void run() {
        System.out.println("奥迪 is running！");
    }
}
```

```java
public class Byd implements Car {
    @Override
    public void run() {
        System.out.println("比亚迪 is running！");
    }
}
```

##### 简单工厂模式

- 简单常用，但违反OCP（开闭原则）。

> OCP（开闭原则）：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
>
> SRP（单一职责原则）：一个类只允许有一个职责，即只有一个导致该类变更的原因。
>
> LSP（里式替换原则）：所有引用基类的地方必须能透明地使用其子类的对象，也就是说子类对象可以替换其父类对象，而程序执行效果不变。
>
> LoD（迪米特法则）：一个对象应该对尽可能少的对象有接触，也就是只接触那些真正需要接触的对象。
>
> ISP（接口分离 原则）：多个特定的客户端接口要好于一个通用性的总接口，应尽量细化接口，接口中的方法应该尽量少。
>
> DIP（依赖倒置原则）：依赖抽象，而不是依赖实现；抽象不应该依赖细节，细节应该依赖抽象；高层模块不能依赖低层模块，二者都应该依赖抽象。
>
> 
>
> **参考资料**：
>
> [面向对象设计的六大设计原则](https://juejin.im/post/5b9526c1e51d450e69731dc2)

```java
public class Client {
    public static void main(String[] args) {
        Car car1 = CarFactory1.createCar("奥迪");
        Car car2 = CarFactory1.createCar("比亚迪");

        car1.run();
        car2.run();
    }
}
```

```java
public class CarFactory1 {

    public static Car createCar(String type) {
        if ("奥迪".equals(type)) {
            return new Audi();
        } else if ("比亚迪".equals(type)) {
            return new Byd();
        } else {
            return null;
        }
    }
}
```

```java
public class CarFactory2 {

    public static Car createAudi() {
        return new Audi();
    }

    public static Car createByd() {
        return new Byd();
    }
}
```

##### 工厂方法模式

```java
public class Client {
    public static void main(String[] args) {
        CarFactory audiFactory = new AudiFactory();
        CarFactory bydFactory = new BydFactory();
        
        Car car1 = audiFactory.createCar();
        Car car2 = bydFactory.createCar();

        car1.run();
        car2.run();
    }
}
```

```java
public interface CarFactory {
    Car createCar();
}
```

```java
public class AudiFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Audi();
    }
}
```

```java
public class BydFactory implements CarFactory {
    @Override
    public Car createCar() {
        return new Byd();
    }
}
```

##### 抽象工厂模式

```java
public class Client {
    public static void main(String[] args) {
        CarFactory luxuryCarFactory = new LuxuryCarFactory();
        
        Car luxuryCar = luxuryCarFactory.createCar();
        
        luxuryCar.engine.start();
    }
}
```

```java
public class Car {

    Engine engine;

    Seat seat;

    Tyre tyre;

    public Car(Engine engine, Seat seat, Tyre tyre) {
        this.engine = engine;
        this.seat = seat;
        this.tyre = tyre;
    }
}
```

```java
public interface CarFactory {

    Car createCar();

    Engine createEngine();

    Seat createSeat();

    Tyre createTyre();
}

class LuxuryCarFactory implements CarFactory {

    @Override
    public Car createCar() {
        return new Car(new LuxuryEngine(),new LuxurySeat(),new LuxuryTyre());
    }

    @Override
    public Engine createEngine() {
        return new LuxuryEngine();
    }

    @Override
    public Seat createSeat() {
        return new LuxurySeat();
    }

    @Override
    public Tyre createTyre() {
        return new LuxuryTyre();
    }
}

class LowCarFactory implements CarFactory {

    @Override
    public Car createCar() {
        return new Car(new LowEngine(),new LowSeat(),new LowTyre());
    }

    @Override
    public Engine createEngine() {
        return new LowEngine();
    }

    @Override
    public Seat createSeat() {
        return new LowSeat();
    }

    @Override
    public Tyre createTyre() {
        return new LowTyre();
    }
}
```

```java
public interface Engine {
    void start();
}

class LuxuryEngine implements Engine {

    @Override
    public void start() {
        System.out.println("启动快!可以自动启停！");
    }
}

class LowEngine implements Engine {

    @Override
    public void start() {
        System.out.println("启动慢！不能自动启停！");
    }
}
```

```java
public interface Seat {
    void massage();
}

class LuxurySeat implements Seat {

    @Override
    public void massage() {
        System.out.println("可以自动按摩！");
    }
}

class LowSeat implements Seat {

    @Override
    public void massage() {
        System.out.println("不可以按摩！");
    }
}
```

```java
public interface Tyre {
    void revolve();
}

class LuxuryTyre implements Tyre {

    @Override
    public void revolve() {
        System.out.println("旋转不磨损！");
    }
}

class LowTyre implements Tyre {

    @Override
    public void revolve() {
        System.out.println("旋转磨损快！");
    }
}
```

#### 总结

- 根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。
- 抽象工厂模式用来生产不同产品族（一个产品）的全部产品（全部零件），支持增加新的产品族（产品），对于增加新的产品（零件）无能为力。
- ![](https://i.imgur.com/3MariLQ.jpg)